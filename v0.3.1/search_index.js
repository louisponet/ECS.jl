var documenterSearchIndex = {"docs":
[{"location":"components/#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"CurrentModule = Overseer","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"AbstractComponent\nComponent\n@component\nPooledComponent\n@pooled_component\ntest_abstractcomponent_interface\nin(::Int, ::AbstractComponent)\npop!(::Component, ::AbstractEntity)\nmake_unique!\npool\nIndices","category":"page"},{"location":"components/#Overseer.AbstractComponent","page":"Components","title":"Overseer.AbstractComponent","text":"Abstract type for all Components. For now the only two AbstractComponents are Component and PooledComponent. Most functionality that is defined for the AbstractComponent type assumes that there is a .indices member field that is of type Indices.\n\nIf this is not the case look at those functions in the src/component.jl file.\n\nOverseer.test_abstractcomponent_interface is an interface test function that you can call to test a new AbstractComponent implementation. See that function for more details.\n\n\n\n\n\n","category":"type"},{"location":"components/#Overseer.Component","page":"Components","title":"Overseer.Component","text":"The most basic Component type.\n\nIndexing into a component with an Entity will return the data linked to that entity, indexing with a regular Int will return directly the data that is stored in the data vector at that index, i.e. generally not the storage linked to the Entity with that Int as id.\n\nTo register a struct to be stored in a Component see @component.\n\n\n\n\n\n","category":"type"},{"location":"components/#Overseer.@component","page":"Components","title":"Overseer.@component","text":"This takes a struct definition and register it so that it will be stored inside a Component when attached to Entities.\n\nExample\n\n```julia @component struct MyComp     v::Float64 end\n\n\n\n\n\n","category":"macro"},{"location":"components/#Overseer.PooledComponent","page":"Components","title":"Overseer.PooledComponent","text":"A PooledComponent allows for sharing data between many Entities. Essentially, the indices into the data pool are stored for each Entity, rather than the data itself.\n\nTo make a struct to be stored inside PooledComponent see @pooled_component.\n\nmake_unique! can be used to check whether duplicate data exists and if so point all Entities to only a single copy and remove the duplicates.\n\nTo interact with the data pools see pool, pools and entity_pool.\n\nExample\n\n@pooled_component struct Comp1\n    comp1\nend\n\ne1 = Entity(ledger, Comp1(1))\ne2 = Entity(ledger)\n\nledger[Comp1][e2] = e1 # The Comp1 data for e2 is set to point to the same as e1 \n\n\n\n\n\n","category":"type"},{"location":"components/#Overseer.@pooled_component","page":"Components","title":"Overseer.@pooled_component","text":"This takes a struct definition and register it so that it will be stored inside a PooledComponent when attached to Entities.\n\n\n\n\n\n","category":"macro"},{"location":"components/#Overseer.test_abstractcomponent_interface","page":"Components","title":"Overseer.test_abstractcomponent_interface","text":"Tests whether an AbstractComponent satisfies the interface.\n\n\n\n\n\n","category":"function"},{"location":"components/#Base.in-Tuple{Int64, Overseer.AbstractComponent}","page":"Components","title":"Base.in","text":"in(entity, component)\n\nChecks whether entity has a data entry in component.\n\n\n\n\n\n","category":"method"},{"location":"components/#Base.pop!-Tuple{Component, Overseer.AbstractEntity}","page":"Components","title":"Base.pop!","text":"pop!(component, entity)\n\npops the data for entity out of component.\n\n\n\n\n\n","category":"method"},{"location":"components/#Overseer.make_unique!","page":"Components","title":"Overseer.make_unique!","text":"Checks whether duplicate data exists in a PooledComponent and if so points all Entities to only a single copy while removing the duplicates.\n\n\n\n\n\n","category":"function"},{"location":"components/#Overseer.pool","page":"Components","title":"Overseer.pool","text":"pool(pooled_compnent, entity)\npool(pooled_compnent, i)\n\nReturns which pool entity or the ith entity belongs to.\n\n\n\n\n\n","category":"function"},{"location":"components/#Overseer.Indices","page":"Components","title":"Overseer.Indices","text":"A variation on the SparseIntSet from DataStructures.jl which forms the backbone of keeping track of which Entities are part of an AbstractComponent and how to access their data.\n\nComplexities:\n\nin: O(1)\npop!: O(1)\npush!: O(1)\ngetindex: O(1)\niterate: O(N)\n\n\n\n\n\n","category":"type"},{"location":"systems/#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"CurrentModule = Overseer","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"System\nStage\nupdate(::System, ::AbstractLedger)\nupdate(::Stage, ::AbstractLedger)\nrequested_components(::System)","category":"page"},{"location":"systems/#Overseer.System","page":"Systems","title":"Overseer.System","text":"Systems represent the part of ECS where the actual \"work\" happens, by overloading the Overseer.update function for a specific System, with the signature Overseer.update(::System, m::AbstractLedger). When updating a Ledger the update function of each system will be called. By overloading Overseer.requested_components, for a System, it is ensured that those components are present in the Ledger that holds the System.  Following the ECS design, a System should not hold data except for maybe some settings parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Overseer.Stage","page":"Systems","title":"Overseer.Stage","text":"Represents a set of Systems that get executed as steps by calling update on those systems. The steps are a Vector of other Stages, Systems, or a Vector of those. During the update call on a Stage, if one of the steps is found to be a Vector it will be assumed that those can be executed at the same time (see the example). The representation of the steps can be thought of as a very crude DAG.\n\nExample\n\nStage(:example_stage, [Sys1, [Sys2, Sys3, Sys4], Sys5])\n\nWhen update is called on this stage, first the update of Sys1 will be called, then 3 tasks will be spawned each calling update for Sys2, Sys3 and Sys4 at the same time. Finally after those complete the update function of Sys5 will be called.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Overseer.update-Tuple{System, AbstractLedger}","page":"Systems","title":"Overseer.update","text":"update(system, ledger, args...)\n\nFunction to be overloaded for any System which will be called during the update call stack.\n\n\n\n\n\n","category":"method"},{"location":"systems/#Overseer.update-Tuple{Stage, AbstractLedger}","page":"Systems","title":"Overseer.update","text":"update(stage, ledger, args...)\n\nrecursively calls update with the ledger on the steps defined in the stage. See the Stage documentation for an explanation of the execution graph.\n\n\n\n\n\n","category":"method"},{"location":"systems/#Overseer.requested_components-Tuple{System}","page":"Systems","title":"Overseer.requested_components","text":"requested_components(::System)\n\nFunction to be overloaded so that when a Ledger is created containing a system, the right AbstractComponents will be added to it.\n\nExamples\n\n@component struct ExampleComp end\n\nstruct ExampleSystem <: System end\n\nOverseer.requested_components(::ExampleSystem) = (ExampleComp,)\n\nl = Ledger(Stage(:example, [ExampleSystem()]))\n\n\n\n\n\n","category":"method"},{"location":"ledger/#Ledger","page":"Ledger","title":"Ledger","text":"","category":"section"},{"location":"ledger/","page":"Ledger","title":"Ledger","text":"CurrentModule = Overseer","category":"page"},{"location":"ledger/","page":"Ledger","title":"Ledger","text":"AbstractLedger\nLedger\nledger\nupdate(::AbstractLedger)\ndelete!(::AbstractLedger, ::AbstractEntity)\nschedule_delete!\ndelete_scheduled!","category":"page"},{"location":"ledger/#Overseer.AbstractLedger","page":"Ledger","title":"Overseer.AbstractLedger","text":"Abstract type for all ECS ledgers. The easiest way to use the interface is by including a standard Ledger as a member field and defining ledger for your new AbstractLedger type to return that field. \n\n\n\n\n\n","category":"type"},{"location":"ledger/#Overseer.Ledger","page":"Ledger","title":"Overseer.Ledger","text":"A Ledger holds all the Entities, Components and Systems. It has interfaces to create new Entities and access the Components. Calling update(ledger) will call all the update functions of the systems in the Ledger.\n\nExample\n\nl = Ledger()\ne1 = Entity(l, CompType1(1, 2))\ne2 = Entity(l, CompType1(1, 2), CompType2(\"comptype2\"))\n\nthis has created a new Ledger with two Entities, the first having 1 component of type CompType1, the second has 2 components.\n\nl[e1]\n\nWill return an EntityState, essentially a bag of Components e1 belongs to.\n\nl[CompType1]\n\nreturns the AbstractComponent holding the data of type CompType1.\n\n\n\n\n\n","category":"type"},{"location":"ledger/#Overseer.ledger","page":"Ledger","title":"Overseer.ledger","text":"ledger(l::AbstractLedger)\n\nReturns the underlying standard Ledger. This is the preferred method to create new AbstractLedgers.\n\nExample\n\nstruct MyLedger <: AbstractLedger\n    base_ledger::Ledger\n    # other fields\nend\n\nOverseer.ledger(m::MyLedger) = m.base_ledger\n# Now you can use MyLedger identically to the standard Ledger\n\n\n\n\n\n","category":"function"},{"location":"ledger/#Overseer.update-Tuple{AbstractLedger}","page":"Ledger","title":"Overseer.update","text":"update(ledger)\n\nUpdates sequentially all Stages that are in the ledger.\n\n\n\n\n\n","category":"method"},{"location":"ledger/#Base.delete!-Tuple{AbstractLedger, Overseer.AbstractEntity}","page":"Ledger","title":"Base.delete!","text":"delete!(ledger, entity)\n\nImmediately removes the data of an Entity from all components, after which the entity itself is removed from the Ledger.\n\n\n\n\n\n","category":"method"},{"location":"ledger/#Overseer.schedule_delete!","page":"Ledger","title":"Overseer.schedule_delete!","text":"schedule_delete!(ledger, entity)\n\nSchedules an Entity to be deleted with delete_scheduled!. This can be useful when wanting to delete entities during iteration which does not guarantee that all entities would be visited when using standard delete!.\n\n\n\n\n\n","category":"function"},{"location":"ledger/#Overseer.delete_scheduled!","page":"Ledger","title":"Overseer.delete_scheduled!","text":"delete_scheduled!(ledger)\n\nDeletes all the Entities that were previously scheduled for deletion with schedule_delete!.\n\n\n\n\n\n","category":"function"},{"location":"entities/#Entities","page":"Entities","title":"Entities","text":"","category":"section"},{"location":"entities/","page":"Entities","title":"Entities","text":"CurrentModule = Overseer","category":"page"},{"location":"entities/","page":"Entities","title":"Entities","text":"Entity\nEntityState\nentity\nlast_entity","category":"page"},{"location":"entities/#Overseer.Entity","page":"Entities","title":"Overseer.Entity","text":"Can be thought of as simply an index to retrieve data associated with the Entity from Components or a Ledger. In the case of a Ledger it will return an EntityState that holds references to all the Components for which the Entity has data.\n\nAn Entity should always first be created from an AbstractLedger by using Entity(ledger, comps...) before it is used. \n\nExample\n\ne = Entity(ledger, Comp1(), Comp2())\nledger[e] # EntityState with references to easily retrieve e's data for Comp1 and Comp2\n\nledger[Comp2][e] # access the Comp2 data of e\nledger[e][Comp2] # identical to above\n\n\n\n\n\n","category":"type"},{"location":"entities/#Overseer.EntityState","page":"Entities","title":"Overseer.EntityState","text":"Combination of an Entity and a bunch of Components for which the Entity has data. It can thus be used as an index similar to a standard Entity, but it also provides some nice ways to retrieve the data associated with it in the Components.\n\nExample\n\n@component struct Comp1\n    comp1\nend\n\n@component mutable struct Comp2\n    comp2\nend\n\n@component struct Comp3\n    comp3\nend    \n\n\nfor e in @entities_in(ledger, Comp1 && Comp2)\n    # e is an EntityState\n    # we can directly access the fields of Comp1 and Comp2 since they have unique names,\n    # and assign a Comp3 to the Entity that's represented by the EntityState\n    \n    ledger[Comp3][e] = Comp3(e.comp1 + e.comp2)\n    # If there are components that have the same name in the EntityState you can access them directly\n    e[Comp1].comp1\n    e[Comp2].comp2\n\n    # If the Components are mutable we can also set their fields using\n    e.comp2 = 3\nend\n\n\n\n\n\n","category":"type"},{"location":"entities/#Overseer.entity","page":"Entities","title":"Overseer.entity","text":"entity(c, i)\n\nReturn the EntityState with the ith Entity and data in Component c.\n\n\n\n\n\n","category":"function"},{"location":"entities/#Overseer.last_entity","page":"Entities","title":"Overseer.last_entity","text":"last_entity(c::AbstractComponent)\n\nRetrieves the last Entity in c.\n\n\n\n\n\n","category":"function"},{"location":"iteration/#Iteration","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"CurrentModule = Overseer","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"@entities_in\n@safe_entities_in\npools\nentity_pool","category":"page"},{"location":"iteration/#Overseer.@entities_in","page":"Iteration","title":"Overseer.@entities_in","text":"@entities_in(comp_expr)\n@entities_in(l, comp_expr)\n\nThis macro creates an iterator that iterates over all entities that are present in the components according to the expression passed to it. Each iteration an EntityState is returned that refers to the entity and the associated data inside the Components.\n\ncomp_expr is a boolean expression that is used to decide which entities to return.\n\nExamples\n\nfor e in @entities_in(comp1 && (comp2 || comp3) && !comp4)\n    # do something with e\nend\n\nfor e in @entities_in(ledger, CompType1 && (CompType2 || CompType3) && !CompType4)\n    # do something with e\nend\n\nAssuming that comp1 = ledger[CompType1] and similar for the others, these expressions will loop over the Entities that are in comp1, in comp2 or comp3, and not in comp4.\n\n\n\n\n\n","category":"macro"},{"location":"iteration/#Overseer.@safe_entities_in","page":"Iteration","title":"Overseer.@safe_entities_in","text":"@safe_entities_in(comp_expr)\n@safe_entities_in(ledger, comp_expr)\n\nSimilar to @entities_in but safe to pop! entities during iteration.\n\n\n\n\n\n","category":"macro"},{"location":"iteration/#Overseer.pools","page":"Iteration","title":"Overseer.pools","text":"pools(c::PooledComponent)\n\nReturns an iterator that loops over the pools in c, returning a Tuple with the data and an iterator like the one gotten from entity_pool.\n\nExample\n\nfor (data, entities) in pools(c)\n    for e in entities\n        # do something with e\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"iteration/#Overseer.entity_pool","page":"Iteration","title":"Overseer.entity_pool","text":"entity_pool(c::PooledComponent, pool_id::Int)\nentity_pool(c::PooledComponent, e::AbstractEntity)\n\nReturns an iterator that iterates over all the Entities in the pool with id == pool_id or the pool to which e belongs.\n\nExample\n\nfor e in entity_pool(c, 1)\n    # do something with e belonging to the first pool of c\nend\n\n\n\n\n\n","category":"function"},{"location":"#Overseer","page":"Home","title":"Overseer","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Overseer","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package supplies a lightweight, performant and julian implementation of the Entity Component System (ECS) programming paradigm. It is most well known for its applications in game development, but I believe it's a programming paradigm that can benefit a broad range of applications. It results in a very clean and flexible way to gradually build up applications in well separated blocks, while remaining inherently performant due to the way data is structured and accessed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The API and performance of this package are being thoroughly tested in practice in the development of:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Glimpse.jl: a mid level rendering toolkit\nTrading.jl: a comprehensive realtime trading and backtesting framework\nRomeoDFT.jl: a robust global DFT based energy optimizer","category":"page"},{"location":"#Illustrative-Example","page":"Home","title":"Illustrative Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"note: Note\nA Component is technically the datastructure that holds the data for a given Type for the Entities that have that data. We will thus use the terminology of an Entity \"having a component\" and \"being part of a component\" interchangeably.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can think of Entities as simply an identifier into Components which are essentially Vectors of data. The key observation is that a System doesn't particularly care which Entity it is handling, only that it has the right data, i.e. that it has entries in the right Components.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We illustrate the concept of ECS with a very basic example were a Mover system will change the position of Entities based on their velocity.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We start by defining a Position and Velocity Component:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Overseer\n\n@component mutable struct Position\n    position::Vector{Float64}\nend\n\n@component struct Velocity\n    velocity::Vector{Float64}\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Systems are represented by a subtype of System, usually these are empty since they should signify the purely functional part of ECS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct Mover <: System end\n\nfunction Overseer.update(::Mover, l::AbstractLedger)\n    dt = 0.01\n    for e in @entities_in(l, Position && Velocity)\n        e.position .+= e.velocity .* dt\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"We see that the Mover system iterates through all entities that have both the Position and Velocity Component (i.e. have data in both components), and updates their position.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can create a Ledger which holds all the Entities, Systems and Components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"l = Ledger(Stage(:basic, [Mover()]))","category":"page"},{"location":"","page":"Home","title":"Home","text":"a Stage is essentially a way to group a set of Systems with some additional DAG-like features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then add a couple of Entities to our ledger","category":"page"},{"location":"","page":"Home","title":"Home","text":"e1 = Entity(l, Position([1,0,0]), Velocity([1,1,1]))\ne2 = Entity(l, Position([2,0,1]), Velocity([1,-1,1]))\ne3 = Entity(l, Position([2,0,1]))\nl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, we can execute all the Systems by calling update on the ledger","category":"page"},{"location":"","page":"Home","title":"Home","text":"update(l)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and look at the final positions","category":"page"},{"location":"","page":"Home","title":"Home","text":"l[Position][e1], l[Position][e2], l[Position][e3]","category":"page"},{"location":"","page":"Home","title":"Home","text":"We see that the position of e3 did not get updated since it did not have the Velocity component and as such was not touched by the Mover system.","category":"page"}]
}
