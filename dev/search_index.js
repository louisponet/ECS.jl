var documenterSearchIndex = {"docs":
[{"location":"components/#Components","page":"Components","title":"Components","text":"","category":"section"},{"location":"components/","page":"Components","title":"Components","text":"CurrentModule = Overseer","category":"page"},{"location":"components/","page":"Components","title":"Components","text":"AbstractComponent\nComponent\n@component\nPooledComponent\n@pooled_component\ntest_abstractcomponent_interface\nin(::Int, ::AbstractComponent)\npop!(::Component, ::AbstractEntity)\nmake_unique!\npool\nIndices","category":"page"},{"location":"components/#Overseer.AbstractComponent","page":"Components","title":"Overseer.AbstractComponent","text":"AbstractComponent\n\nAbstract type for all Components. For now the only two AbstractComponents are Component and PooledComponent. Most functionality that is defined for the AbstractComponent type assumes that there is a .indices member field that is of type Indices.\n\nIf this is not the case look at those functions in the src/component.jl file.\n\nOverseer.test_abstractcomponent_interface is an interface test function that you can call to test a new AbstractComponent implementation. See that function for more details.\n\n\n\n\n\n","category":"type"},{"location":"components/#Overseer.Component","page":"Components","title":"Overseer.Component","text":"Component\n\nThe most basic Component type.\n\nIndexing into a component with an Entity will return the data linked to that entity, indexing with a regular Int will return directly the data that is stored in the data vector at that index, i.e. generally not the storage linked to the Entity with that Int as id.\n\nTo register a struct to be stored in a Component see @component.\n\n\n\n\n\n","category":"type"},{"location":"components/#Overseer.@component","page":"Components","title":"Overseer.@component","text":"@component\n\nThis takes a struct definition and register it so that it will be stored inside a Component when attached to Entities.\n\n\n\n\n\n","category":"macro"},{"location":"components/#Overseer.PooledComponent","page":"Components","title":"Overseer.PooledComponent","text":"PooledComponent\n\nA PooledComponent allows for sharing data between many Entities. Essentially, the indices into the data pool are stored for each Entity, rather than the data itself.\n\nTo make a struct to be stored inside PooledComponent see @pooled_component.\n\nmake_unique! can be used to check whether duplicate data exists and if so point all Entities to only a single copy and remove the duplicates.\n\nTo interact with the data pools see pool, pools and entity_pool.\n\nExample\n\n@pooled_component struct Comp1\n    comp1\nend\n\ne1 = Entity(ledger, Comp1(1))\ne2 = Entity(ledger)\n\nledger[Comp1][e2] = e1 # The Comp1 data for e2 is set to point to the same as e1 \n\n\n\n\n\n","category":"type"},{"location":"components/#Overseer.@pooled_component","page":"Components","title":"Overseer.@pooled_component","text":"@pooled_component\n\nThis takes a struct definition and register it so that it will be stored inside a PooledComponent when attached to Entities.\n\n\n\n\n\n","category":"macro"},{"location":"components/#Overseer.test_abstractcomponent_interface","page":"Components","title":"Overseer.test_abstractcomponent_interface","text":"Tests whether an AbstractComponent satisfies the interface.\n\n\n\n\n\n","category":"function"},{"location":"components/#Base.in-Tuple{Int64, Overseer.AbstractComponent}","page":"Components","title":"Base.in","text":"in(entity, component)\n\nChecks whether entity has a data entry in component.\n\n\n\n\n\n","category":"method"},{"location":"components/#Base.pop!-Tuple{Component, Overseer.AbstractEntity}","page":"Components","title":"Base.pop!","text":"pop!(component, entity)\n\npops the data for entity out of component.\n\n\n\n\n\n","category":"method"},{"location":"components/#Overseer.make_unique!","page":"Components","title":"Overseer.make_unique!","text":"make_unique!\n\nChecks whether duplicate data exists in a PooledComponent and if so points all Entities to only a single copy while removing the duplicates.\n\n\n\n\n\n","category":"function"},{"location":"components/#Overseer.pool","page":"Components","title":"Overseer.pool","text":"pool(pooled_compnent, entity)\npool(pooled_compnent, i)\n\nReturns which pool entity or the ith entity belongs to.\n\n\n\n\n\n","category":"function"},{"location":"components/#Overseer.Indices","page":"Components","title":"Overseer.Indices","text":"Indices\n\nA variation on the SparseIntSet from DataStructures.jl which forms the backbone of keeping track of which Entities are part of an AbstractComponent and how to access their data.\n\nComplexities:\n\nin: O(1)\npop!: O(1)\npush!: O(1)\ngetindex: O(1)\niterate: O(N)\n\n\n\n\n\n","category":"type"},{"location":"systems/#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"CurrentModule = Overseer","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"System\nStage\nupdate(::System, ::AbstractLedger)\nupdate(::Stage, ::AbstractLedger)\nrequested_components(::System)","category":"page"},{"location":"systems/#Overseer.System","page":"Systems","title":"Overseer.System","text":"System\n\nSystems represent the part of ECS where the actual \"work\" happens, by overloading the Overseer.update function for a specific System, with the signature Overseer.update(::System, m::AbstractLedger). When updating a Ledger the update function of each system will be called. By overloading Overseer.requested_components, for a System, it is ensured that those components are present in the Ledger that holds the System.  Following the ECS design, a System should not hold data except for maybe some settings parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Overseer.Stage","page":"Systems","title":"Overseer.Stage","text":"Stage\n\nRepresents a set of Systems that get executed as steps by calling update on those systems. The steps are a Vector of other Stages, Systems, or a Vector of those. During the update call on a Stage, if one of the steps is found to be a Vector it will be assumed that those can be executed at the same time (see the example). The representation of the steps can be thought of as a very crude DAG.\n\nExample\n\nStage(:example_stage, [Sys1, [Sys2, Sys3, Sys4], Sys5])\n\nWhen update is called on this stage, first the update of Sys1 will be called, then 3 tasks will be spawned each calling update for Sys2, Sys3 and Sys4 at the same time. Finally after those complete the update function of Sys5 will be called.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Overseer.update-Tuple{System, AbstractLedger}","page":"Systems","title":"Overseer.update","text":"update(system, ledger, args...)\n\nFunction to be overloaded for any System which will be called during the update call stack.\n\n\n\n\n\n","category":"method"},{"location":"systems/#Overseer.update-Tuple{Stage, AbstractLedger}","page":"Systems","title":"Overseer.update","text":"update(stage, ledger, args...)\n\nrecursively calls update with the ledger on the steps defined in the stage. See the Stage documentation for an explanation of the execution graph.\n\n\n\n\n\n","category":"method"},{"location":"systems/#Overseer.requested_components-Tuple{System}","page":"Systems","title":"Overseer.requested_components","text":"requested_components(::System)\n\nFunction to be overloaded so that when a Ledger is created containing a system, the right AbstractComponents will be added to it.\n\nExamples\n\n@component struct ExampleComp end\n\nstruct ExampleSystem <: System end\n\nOverseer.requested_components(::ExampleSystem) = (ExampleComp,)\n\nl = Ledger(Stage(:example, [ExampleSystem()]))\n\n\n\n\n\n","category":"method"},{"location":"ledger/#Ledger","page":"Ledger","title":"Ledger","text":"","category":"section"},{"location":"ledger/","page":"Ledger","title":"Ledger","text":"CurrentModule = Overseer","category":"page"},{"location":"ledger/","page":"Ledger","title":"Ledger","text":"AbstractLedger\nLedger\nledger\nupdate(::AbstractLedger)\ndelete!(::AbstractLedger, ::AbstractEntity)\nschedule_delete!\ndelete_scheduled!","category":"page"},{"location":"ledger/#Overseer.AbstractLedger","page":"Ledger","title":"Overseer.AbstractLedger","text":"AbstractLedger\n\nAbstract type for all ECS ledgers. The easiest way to use the interface is by including a standard Ledger as a member field and defining ledger for your new AbstractLedger type to return that field. \n\n\n\n\n\n","category":"type"},{"location":"ledger/#Overseer.Ledger","page":"Ledger","title":"Overseer.Ledger","text":"Ledger\n\nA Ledger holds all the Entities, Components and Systems. It has interfaces to create new Entities and access the Components. Calling update(ledger) will call all the update functions of the systems in the Ledger.\n\nExample\n\nl = Ledger()\ne1 = Entity(l, CompType1(1, 2))\ne2 = Entity(l, CompType1(1, 2), CompType2(\"comptype2\"))\n\nthis has created a new Ledger with two Entities, the first having 1 component of type CompType1, the second has 2 components.\n\nl[e1]\n\nWill return an EntityState, essentially a bag of Components e1 belongs to.\n\nl[CompType1]\n\nreturns the AbstractComponent holding the data of type CompType1.\n\n\n\n\n\n","category":"type"},{"location":"ledger/#Overseer.ledger","page":"Ledger","title":"Overseer.ledger","text":"ledger(l::AbstractLedger)\n\nReturns the underlying standard Ledger. This is the preferred method to create new AbstractLedgers.\n\nExample\n\nstruct MyLedger <: AbstractLedger\n    base_ledger::Ledger\n    # other fields\nend\n\nOverseer.ledger(m::MyLedger) = m.base_ledger\n# Now you can use MyLedger identically to the standard Ledger\n\n\n\n\n\n","category":"function"},{"location":"ledger/#Overseer.update-Tuple{AbstractLedger}","page":"Ledger","title":"Overseer.update","text":"update(ledger)\n\nUpdates sequentially all Stages that are in the ledger.\n\n\n\n\n\n","category":"method"},{"location":"ledger/#Base.delete!-Tuple{AbstractLedger, Overseer.AbstractEntity}","page":"Ledger","title":"Base.delete!","text":"delete!(ledger, entity)\n\nImmediately removes the data of an Entity from all components, after which the entity itself is removed from the Ledger.\n\n\n\n\n\n","category":"method"},{"location":"ledger/#Overseer.schedule_delete!","page":"Ledger","title":"Overseer.schedule_delete!","text":"schedule_delete!(ledger, entity)\n\nSchedules an Entity to be deleted with delete_scheduled!. This can be useful when wanting to delete entities during iteration which does not guarantee that all entities would be visited when using standard delete!.\n\n\n\n\n\n","category":"function"},{"location":"ledger/#Overseer.delete_scheduled!","page":"Ledger","title":"Overseer.delete_scheduled!","text":"delete_scheduled!(ledger)\n\nDeletes all the Entities that were previously scheduled for deletion with schedule_delete!.\n\n\n\n\n\n","category":"function"},{"location":"entities/#Entities","page":"Entities","title":"Entities","text":"","category":"section"},{"location":"entities/","page":"Entities","title":"Entities","text":"CurrentModule = Overseer","category":"page"},{"location":"entities/","page":"Entities","title":"Entities","text":"Entity\nEntityState\nentity\nlast_entity","category":"page"},{"location":"entities/#Overseer.Entity","page":"Entities","title":"Overseer.Entity","text":"Entity\n\nCan be thought of as simply an index to retrieve data associated with the Entity from Components or a Ledger. In the case of a Ledger it will return an EntityState that holds references to all the Components for which the Entity has data.\n\nAn Entity should always first be created from an AbstractLedger by using Entity(ledger, comps...) before it is used. \n\nExample\n\ne = Entity(ledger, Comp1(), Comp2())\nledger[e] # EntityState with references to easily retrieve e's data for Comp1 and Comp2\n\nledger[Comp2][e] # access the Comp2 data of e\nledger[e][Comp2] # identical to above\n\n\n\n\n\n","category":"type"},{"location":"entities/#Overseer.EntityState","page":"Entities","title":"Overseer.EntityState","text":"EntityState\n\nCombination of an Entity and a bunch of Components for which the Entity has data. It can thus be used as an index similar to a standard Entity, but it also provides some nice ways to retrieve the data associated with it in the Components.\n\nExample\n\n@component struct Comp1\n    comp1\nend\n\n@component mutable struct Comp2\n    comp2\nend\n\n@component struct Comp3\n    comp3\nend    \n\n\nfor e in @entities_in(ledger, Comp1 && Comp2)\n    # e is an EntityState\n    # we can directly access the fields of Comp1 and Comp2 since they have unique names,\n    # and assign a Comp3 to the Entity that's represented by the EntityState\n    \n    ledger[Comp3][e] = Comp3(e.comp1 + e.comp2)\n    # If there are components that have the same name in the EntityState you can access them directly\n    e[Comp1].comp1\n    e[Comp2].comp2\n\n    # If the Components are mutable we can also set their fields using\n    e.comp2 = 3\nend\n\n\n\n\n\n","category":"type"},{"location":"entities/#Overseer.entity","page":"Entities","title":"Overseer.entity","text":"entity(c, i)\n\nReturn the EntityState with the ith Entity and data in Component c.\n\n\n\n\n\n","category":"function"},{"location":"entities/#Overseer.last_entity","page":"Entities","title":"Overseer.last_entity","text":"last_entity(c::AbstractComponent)\n\nRetrieves the last Entity in c.\n\n\n\n\n\n","category":"function"},{"location":"iteration/#Iteration","page":"Iteration","title":"Iteration","text":"","category":"section"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"CurrentModule = Overseer","category":"page"},{"location":"iteration/","page":"Iteration","title":"Iteration","text":"@entities_in\n@safe_entities_in\npools\nentity_pool","category":"page"},{"location":"iteration/#Overseer.@entities_in","page":"Iteration","title":"Overseer.@entities_in","text":"@entities_in(comp_expr)\n@entities_in(l, comp_expr)\n\nThis macro creates an iterator that iterates over all entities that are present in the components according to the expression passed to it. Each iteration an EntityState is returned that refers to the entity and the associated data inside the Components.\n\ncomp_expr is a boolean expression that is used to decide which entities to return.\n\nExamples\n\nfor e in @entities_in(comp1 && (comp2 || comp3) && !comp4)\n    # do something with e\nend\n\nfor e in @entities_in(ledger, CompType1 && (CompType2 || CompType3) && !CompType4)\n    # do something with e\nend\n\nAssuming that comp1 = ledger[CompType1] and similar for the others, these expressions will loop over the Entities that are in comp1, in comp2 or comp3, and not in comp4.\n\n\n\n\n\n","category":"macro"},{"location":"iteration/#Overseer.@safe_entities_in","page":"Iteration","title":"Overseer.@safe_entities_in","text":"@safe_entities_in(comp_expr)\n@safe_entities_in(ledger, comp_expr)\n\nSimilar to @entities_in but safe to pop! entities during iteration.\n\n\n\n\n\n","category":"macro"},{"location":"iteration/#Overseer.pools","page":"Iteration","title":"Overseer.pools","text":"pools(c::PooledComponent)\n\nReturns an iterator that loops over the pools in c, returning a Tuple with the data and an iterator like the one gotten from entity_pool.\n\nExample\n\nfor (data, entities) in pools(c)\n    for e in entities\n        # do something with e\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"iteration/#Overseer.entity_pool","page":"Iteration","title":"Overseer.entity_pool","text":"entity_pool(c::PooledComponent, pool_id::Int)\nentity_pool(c::PooledComponent, e::AbstractEntity)\n\nReturns an iterator that iterates over all the Entities in the pool with id == pool_id or the pool to which e belongs.\n\nExample\n\nfor e in entity_pool(c, 1)\n    # do something with e belonging to the first pool of c\nend\n\n\n\n\n\n","category":"function"},{"location":"#Overseer","page":"Home","title":"Overseer","text":"","category":"section"}]
}
